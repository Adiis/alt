<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Creating Stores</title>
  <meta name="description" content="A library for managing data within JavaScript applications. Alt is a pure flux implementation that is small, terse, well tested, extremely flexible, and forward thinking.
">

  <link rel="canonical" href="http://alt.js.org/docs/createStore/">
  <link rel="alternate" type="application/rss+xml" title="Alt" href="http://alt.js.org/feed.xml" />

  <link type="text/css" rel="stylesheet" href="/assets/bootstrap-navbar.css" />
  <link type="text/css" rel="stylesheet" href="/assets/lotus.min.css" />
  <link type="text/css" rel="stylesheet" href="/assets/prism.min.css" />
  <link type="text/css" rel="stylesheet" href="/assets/styles.css" />
</head>


  <body>

    <nav class="navbar navbar-default sp-horiz-lg">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a class="navbar-brand" href="/"><img src="/assets/alt.png" alt="Alt" width="40" /></a>
    </div>

    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <div id="alt-search-app"></div>
      <ul class="nav navbar-nav navbar-right">
        <li>
          <a href="/guide/">Getting Started</a>
        </li>
        <li class="dropdown">
          <a href='#' class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">API Documentation <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li>
              <a href="/docs/">Alt</a>
            </li>
            
            <li>
              <a href="/docs/createActions">Creating Actions</a>
            </li>
            
            <li>
              <a href="/docs/actions">Actions</a>
            </li>
            
            <li>
              <a href="/docs/createStore">Creating Stores</a>
            </li>
            
            <li>
              <a href="/docs/stores">Stores</a>
            </li>
            
            <li>
              <a href="/docs/async">Handling Async</a>
            </li>
            
            <li>
              <a href="/docs/lifecycleListeners">Lifecycle Listeners</a>
            </li>
            
            <li>
              <a href="/docs/bootstrap">Bootstrap</a>
            </li>
            
            <li>
              <a href="/docs/takeSnapshot">Take Snapshot</a>
            </li>
            
            <li>
              <a href="/docs/flush">Flush</a>
            </li>
            
            <li>
              <a href="/docs/recycle">Recycle</a>
            </li>
            
            <li>
              <a href="/docs/rollback">Rollback</a>
            </li>
            
            <li>
              <a href="/docs/altInstances">Alt Instances</a>
            </li>
            
            <li>
              <a href="/docs/components/altContainer">AltContainer</a>
            </li>
            
          </ul>
        </li>
        <li>
          <a href="/blog/">Blog</a>
        </li>
        <li>
          <a href="https://gitter.im/goatslacker/alt">Support</a>
        </li>
        <li>
          <a href="https://github.com/goatslacker/alt">GitHub</a>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


    <div class="main sp-vert-md sp-horiz-lg">
      <div class="row">
        <div class="col c2">
          <ul class="sidenav">
  
  <li>
    <a href="/docs/createActions">Creating Actions</a>
  </li>
  
  <li>
    <a href="/docs/actions">Actions</a>
  </li>
  
  <li>
    <a href="/docs/createStore">Creating Stores</a>
  </li>
  
  <li>
    <a href="/docs/stores">Stores</a>
  </li>
  
  <li>
    <a href="/docs/async">Handling Async</a>
  </li>
  
  <li>
    <a href="/docs/lifecycleListeners">Lifecycle Listeners</a>
  </li>
  
  <li>
    <a href="/docs/bootstrap">Bootstrap</a>
  </li>
  
  <li>
    <a href="/docs/takeSnapshot">Take Snapshot</a>
  </li>
  
  <li>
    <a href="/docs/flush">Flush</a>
  </li>
  
  <li>
    <a href="/docs/recycle">Recycle</a>
  </li>
  
  <li>
    <a href="/docs/rollback">Rollback</a>
  </li>
  
  <li>
    <a href="/docs/altInstances">Alt Instances</a>
  </li>
  
  <li>
    <a href="/docs/components/altContainer">AltContainer</a>
  </li>
  
</ul>

        </div>
        <div class="col c10">
          <div class="sp-horiz-md">
            <h1 id="createstore">createStore</h1>

<blockquote>
  <p>(StoreModel: function, iden: ?string, …constructorArgs): <a href="/docs/stores">AltStore</a></p>
</blockquote>

<p>This is a function that takes in a class of your store and returns back the singleton store. The second parameter <code>iden</code> is a string that is used as a unique identifier for serializing/deserializing your store. The name of the store comes from the class name but on production due to heavy minification it is a good idea to provide your own name to avoid collisions. <code>constructorArgs</code> are passed to the <code>StoreModel</code> constructor (if <code>StoreModel</code> is a class).</p>

<h1 id="storemodel">StoreModel</h1>

<h2 id="storemodelconfig">StoreModel.config</h2>

<p>The config object on your store classes allow you to configure your stores for specific behavior.</p>

<p>Available configuration options:</p>

<h4 id="setstate">setState</h4>

<blockquote>
  <p>setState(currentState: object, nextState: object): object</p>
</blockquote>

<p><code>setState</code> is used internally by Alt to set the state. You can override this to provide your own setState implementation. Internally, setState is an alias for <code>Object.assign</code>. <code>setState</code> must return an object.</p>

<h4 id="getstate">getState</h4>

<blockquote>
  <p>getState(currentState: object): mixed</p>
</blockquote>

<p><code>getState</code> receives the current state and returns a copy of it. You can override this function to provide your own implementation.</p>

<h4 id="onserialize">onSerialize</h4>

<p><code>onSerialize</code> is also called before the store’s state is serialized. You may optionally return an object, which will be used directly as the snapshot data for the store. If you do not return anything, the default, <a href="/docs/stores#storegetstate"><code>MyStore#getState()</code></a> is used for the snapshot data. See the <a href="/docs/serialization">serialization</a> for an example.</p>

<pre><code class="language-js">class TodoStore {
  static config = {
    onSerialize: function(data) {
      // do something here
      // optional return of data to be used in snapshot
      // return mySnapshotData
    }
  }
}
</code></pre>

<h4 id="ondeserialize">onDeserialize</h4>

<p><code>onDeserialize</code> is called before the store’s state is deserialized. This occurs whenever the store’s state is being set to an existing snapshot/bootstrap data. Here you can perform any final tasks you need to before the snapshot/bootstrap data is set on the store such as mapping the data to model objects, or converting data an external source like a JSON API into a format the store expects. <code>onDeserialize</code> takes in a parameter that is an object of snapshot/bootstrap data and must return the data to be set to the store’s state. If nothing is returned, then the data from the snapshot is set to the store’s state. See the <a href="/docs/serialization">serialization</a> for an example.</p>

<pre><code class="language-js">class TodoStore {
  static config = {
    onDeserialize: function(data) {
      // do something here
      return modifiedData
    }
  }
}
</code></pre>

<h2 id="storemodelconstructor">StoreModel#constructor</h2>

<blockquote>
  <p>(…args): StoreModel</p>
</blockquote>

<p>The constructor of your store definition receives any constructor arguments passed through the <a href="#createStore"><code>createStore</code></a> function. All instance variables, values assigned to <code>this</code>, in any part of the StoreModel will become part of state.</p>

<h2 id="storemodelon">StoreModel#on</h2>

<blockquote>
  <p>(lifecycleMethod: string, handler: function): undefined</p>
</blockquote>

<p>This method can be used to listen to <a href="/docs/lifecycleListeners">Lifecycle events</a>. Normally they would be set up in the constructor.</p>

<pre><code class="language-js">class MyStore {
  constructor() {
    this.on('bootstrap', () =&gt; {
    });
  }
}
</code></pre>

<h2 id="storemodelbindaction">StoreModel#bindAction</h2>

<blockquote>
  <p>(actionsSymbol: symbol, storeHandler: function): undefined</p>
</blockquote>

<p>This method takes in an <a href="/docs/actions#actionconstant">action’s symbol</a> and a store’s method defined in your StoreModel class. The store’s method is then bound to that action so whenever the action <a href="/docs/createActions#actionsclassdispatch">dispatches</a> a payload, the specified handler will receive it.</p>

<pre><code class="language-js">class MyStore {
  constructor() {
    this.bindAction(MyActions.FOO, this.handleFoo);
  }

  handleFoo(data) {
    // do something with data
  }
}
</code></pre>

<h2 id="storemodelbindactions">StoreModel#bindActions</h2>

<blockquote>
  <p>(actions: object): undefined</p>
</blockquote>

<p>This is a magic method which takes in an object of action symbols and binds them to their specially named handlers which are defined in the StoreModel. An action with the name <code>foo</code> will match an action handler method defined in the StoreModel named <code>onFoo</code> or just <code>foo</code> but not both.</p>

<pre><code class="language-js">class MyStore {
  constructor() {
    this.bindActions(MyActions);
  }

  onFoo(data) {
    // do something with data
  }
}
</code></pre>

<h2 id="storemodelbindlisteners">StoreModel#bindListeners</h2>

<blockquote>
  <p>(listenersMap: object): undefined</p>
</blockquote>

<p><code>bindListeners</code> is the inversion of <code>bindAction</code> but in a much more convenient way. With this method you can exercise precise control over which actions you wish your store listens to and what handlers those actions are bound to. <code>bindListeners</code> accepts an object where the keys correspond to the method in your StoreModel and the values can either be an array of <a href="/docs/actions#actionconstant">action symbols</a> or a single <a href="/docs/actions#actionconstant">action symbol</a>.</p>

<pre><code class="language-js">class MyStore {
  constructor() {
    this.bindListeners({
      handleFoo: MyActions.FOO,
      handleBar: [MyActions.BAR, OtherActions.BAR]
    });
  }

  handleFoo(data) {
    // will only be called by MyActions.foo()
  }

  handleBar(data) {
    // will be called by MyActions.bar() and OtherActions.bar()
  }
}
</code></pre>

<h2 id="storemodelwaitfor">StoreModel#waitFor</h2>

<blockquote>
  <p>(dispatcherSource: mixed): undefined</p>
</blockquote>

<p><code>dispatcherSource</code> can be either a single token/source or an array of tokens/sources. <code>waitFor</code> is mostly an alias for the flux dispatcher’s waitFor method. This method is used to enable dependencies between stores and signal to the dispatcher that this store needs to wait for another store to update first before it can be updated itself.</p>

<pre><code class="language-js">class MyStore {
  onFoo(data) {

    // All of these do the same thing:
    this.waitFor(OtherStore);
    this.waitFor(OtherStore.dispatchToken);

    // You can also pass in multiple stores, these are all the same:
    this.waitFor([Store1, Store2]);
    this.waitFor([Store1.dispatchToken, Store2.dispatchToken]);
    this.waitFor(Store1, Store2);
    this.waitFor(Store1.dispatchToken, Store2.dispatchToken);

    // handle data once OtherStore is updated
  }
}
</code></pre>

<h2 id="storemodelsetstate">StoreModel#setState</h2>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>(state = {}: function</td>
        <td>object): undefined</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p><code>setState</code> is the recommended way to set state for a store. This method automatically emits a change event. <code>setState</code> also accepts a function which returns an object of the state to be set. For convenience, calls to <code>setState</code> are automatically batched as they are in React and only one change event will be emitted once the action finishes dispatching.</p>

<pre><code class="language-js">class MyStore {
  handleFoo() {
    this.state = { foo: 0 };

    setTimeout(() =&gt; {
      // set foo to 1 and emit a change.
      this.setState({
        foo: 1
      });
    }, 100);

    // supress emitting a change.
    this.preventDefault();
  }
}
</code></pre>

<h2 id="storemodelexportpublicmethods">StoreModel#exportPublicMethods</h2>

<blockquote>
  <p>(methods: object): undefined</p>
</blockquote>

<p><code>exportPublicMethods</code> is an explicit, less magical alternative to declaring public methods as type <code>static</code>. The method accepts an object where the keys correspond to a method that exists inside or outside the StoreModel object.</p>

<pre><code class="language-js">const externalFunc = () =&gt; {
  // do something
};

class StoreBase {
  baseMethod() {
    // do something
  }
}

class Store extends StoreBase {
  constructor() {
    this.exportPublicMethods({
      baseMethod: this.baseMethod,
      ownMethod: this.ownMethod,
      externalFunc: externalFunc
    });
  }

  ownMethod() {
    // do something
  }
}
</code></pre>

<h2 id="storemodelgetinstance">StoreModel#getInstance</h2>

<blockquote>
  <p>(): (AltStore)[stores.md]</p>
</blockquote>

<p>This method retrieves the store instance which contains any of the public methods you’ve exported as well as the listen/unlisten methods.</p>

<pre><code class="language-js">class MyStore {
  constructor() {
    this.exportPublicMethods({
      accessToPublicMethod: () =&gt; 2
    });
  }

  handleFoo() {
    this.getInstance().accessToPublicMethod();
  }
}
</code></pre>

<h2 id="storemodelemitchange">StoreModel#emitChange</h2>

<blockquote>
  <p>(): undefined</p>
</blockquote>

<p>Shorthand for emitting a change from within a store.</p>

<pre><code class="language-js">class MyStore {
  handleFoo() {
    setTimeout(() =&gt; {
      this.emitChange();
    }, 100);

    // supress emitting a change.
    this.preventDefault();
  }
}
</code></pre>

<h2 id="storemodeldispatcher">StoreModel#dispatcher</h2>

<p>This is a reference to the dispatcher used by alt which is flux’s own dispatcher. You may use this to listen in on all the global dispatches yourself.</p>

<pre><code class="language-js">this.dispatcher.register(function (payload) {
  console.log(payload);
});
</code></pre>

<h2 id="storemodelalt">StoreModel#alt</h2>

<p>This is a reference to the alt instance. It can be used for getting other stores, dispatching, recycling, flushing, bootstrapping, snapshotting, etc. If you’re using alt stores as <a href="/docs/altInstances">instances</a> rather than singletons then this property is very useful.</p>

<pre><code class="language-js">class MyStore {
  constructor() {
    const actions = this.alt.getActions('MyActions');
  }
}
</code></pre>

<h2 id="storemodeldisplayname">StoreModel#displayName</h2>

<p>This is a reference to the store’s internal name. This is either the identifier you provided to <code>createStore</code> or StoreModel’s class name.</p>

<h2 id="storemodelotherwise">StoreModel#otherwise</h2>

<blockquote>
  <p>otherwise(data, action)</p>
</blockquote>

<p>This is a method you can implement in your store in order to receive all dispatches that are not currently being handled in your store explicitly via bindActions, bindAction, or bindListeners. This is similar to guards matching in Haskell.</p>

<h2 id="storemodeloutput">StoreModel#output</h2>

<blockquote>
  <p>output(state): {}</p>
</blockquote>

<p>A method you can use to control the output of what gets sent down to <code>listen()</code> as “state”.</p>

<pre><code class="language-js">output(state) {
  return { foo: 'bar' }
}

store.listen((state) =&gt; {
  state.foo === 'bar'
})
</code></pre>

<h2 id="storemodelreduce">StoreModel#reduce</h2>

<blockquote>
  <p>reduce(state, { action, data }): {}</p>
</blockquote>

<p>Another method you can implement in your store. This method receives all dispatches and the result that is returned is then set as the new state of your store. This way you can write your stores as reducers of dispatches.</p>

<h2 id="storemodelpreventdefault">StoreModel#preventDefault</h2>

<p>You may call this method in order to suppress a change event from being pushed. Alternatively, you can just return <code>false</code> from your action handler in your store.</p>

<h2 id="storemodelobserve">StoreModel#observe</h2>

<blockquote>
  <p>observe(alt): {}</p>
</blockquote>

<p>A method you can implement in your stores, mostly useful when using plain objects to create a store. This method will receive the current alt instance and returns an object containing the methods/actions it’ll handle.</p>

          </div>
        </div>
      </div>
    </div>

    <script type="application/javascript" src="http://alt.js.org/assets/search.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.js"></script>
<script type="text/javascript">
  // Alias for javascript so syntax highlighting works fine
  Prism.languages.js = Prism.languages.javascript;
</script>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.2.min.js" ></script>
<script type="text/javascript" src="/assets/bootstrap-navbar.min.js"></script>
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'goatslacker/alt'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>


  </body>

</html>
