<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>AltContainer</title>
  <meta name="description" content="A library for managing data within JavaScript applications. Alt is a pure flux implementation that is small, terse, well tested, extremely flexible, and forward thinking.
">

  <link rel="canonical" href="http://alt.js.org/docs/components/altContainer/">
  <link rel="alternate" type="application/rss+xml" title="Alt" href="http://alt.js.org/feed.xml" />

  <link type="text/css" rel="stylesheet" href="/assets/bootstrap-navbar.css" />
  <link type="text/css" rel="stylesheet" href="/assets/lotus.min.css" />
  <link type="text/css" rel="stylesheet" href="/assets/prism.min.css" />
  <link type="text/css" rel="stylesheet" href="/assets/styles.css" />
</head>


  <body>

    <nav class="navbar navbar-default sp-horiz-lg">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a class="navbar-brand" href="/"><img src="/assets/alt.png" alt="Alt" width="40" /></a>
    </div>

    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <div id="alt-search-app"></div>
      <ul class="nav navbar-nav navbar-right">
        <li>
          <a href="/guide/">Getting Started</a>
        </li>
        <li class="dropdown">
          <a href='#' class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">API Documentation <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li>
              <a href="/docs/">Alt</a>
            </li>
            
            <li>
              <a href="/docs/createActions">Creating Actions</a>
            </li>
            
            <li>
              <a href="/docs/actions">Actions</a>
            </li>
            
            <li>
              <a href="/docs/createStore">Creating Stores</a>
            </li>
            
            <li>
              <a href="/docs/stores">Stores</a>
            </li>
            
            <li>
              <a href="/docs/async">Handling Async</a>
            </li>
            
            <li>
              <a href="/docs/lifecycleListeners">Lifecycle Listeners</a>
            </li>
            
            <li>
              <a href="/docs/bootstrap">Bootstrap</a>
            </li>
            
            <li>
              <a href="/docs/takeSnapshot">Take Snapshot</a>
            </li>
            
            <li>
              <a href="/docs/flush">Flush</a>
            </li>
            
            <li>
              <a href="/docs/recycle">Recycle</a>
            </li>
            
            <li>
              <a href="/docs/rollback">Rollback</a>
            </li>
            
            <li>
              <a href="/docs/altInstances">Alt Instances</a>
            </li>
            
            <li>
              <a href="/docs/components/altContainer">AltContainer</a>
            </li>
            
          </ul>
        </li>
        <li>
          <a href="/blog/">Blog</a>
        </li>
        <li>
          <a href="https://gitter.im/goatslacker/alt">Support</a>
        </li>
        <li>
          <a href="https://github.com/goatslacker/alt">GitHub</a>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


    <div class="main sp-vert-md sp-horiz-lg">
      <div class="row">
        <div class="col c2">
          <ul class="sidenav">
  
  <li>
    <a href="/docs/createActions">Creating Actions</a>
  </li>
  
  <li>
    <a href="/docs/actions">Actions</a>
  </li>
  
  <li>
    <a href="/docs/createStore">Creating Stores</a>
  </li>
  
  <li>
    <a href="/docs/stores">Stores</a>
  </li>
  
  <li>
    <a href="/docs/async">Handling Async</a>
  </li>
  
  <li>
    <a href="/docs/lifecycleListeners">Lifecycle Listeners</a>
  </li>
  
  <li>
    <a href="/docs/bootstrap">Bootstrap</a>
  </li>
  
  <li>
    <a href="/docs/takeSnapshot">Take Snapshot</a>
  </li>
  
  <li>
    <a href="/docs/flush">Flush</a>
  </li>
  
  <li>
    <a href="/docs/recycle">Recycle</a>
  </li>
  
  <li>
    <a href="/docs/rollback">Rollback</a>
  </li>
  
  <li>
    <a href="/docs/altInstances">Alt Instances</a>
  </li>
  
  <li>
    <a href="/docs/components/altContainer">AltContainer</a>
  </li>
  
</ul>

        </div>
        <div class="col c10">
          <div class="sp-horiz-md">
            <h1 id="altcontainer">AltContainer</h1>

<p>AltContainer is not an idea exclusive to alt. For more information on why you should be using container components check out React.js Conf 2015 talk <a href="https://youtu.be/KYzlpRvWZ6c?t=22m48s">Making your app fast with high-performance components</a>.</p>

<p>The basic idea is that you have a container that wraps your component, the duty of this container component is to handle all the data fetching and communication with the stores, it then renders the corresponding children. The sub-components just render markup and are data agnostic thus making them highly reusable.</p>

<p>AltContainer doesn’t just wrap your dumb components into a high-performance store listener but it also serves as a jack-of-all-trades component where you can directly inject any dependencies into your components such as stores, actions, or the flux context.</p>

<h2 id="importing">Importing</h2>

<p>To import <code>AltContainer</code>, you may do it like the following:</p>

<pre><code class="language-js">import AltContainer from 'alt-container';
</code></pre>

<p><strong>For CommonJS</strong>:</p>

<pre><code class="language-js">var AltContainer = require('alt-container');
</code></pre>

<h2 id="stores"><code>stores</code></h2>

<p>You can pass in an object to <code>stores</code> where the keys correspond to the prop that the children will receive and their value the store we should retrieve the state from.</p>

<p>For example:</p>

<pre><code class="language-js">&lt;AltContainer
  stores={
    {
      BlogPosts: BlogStore,
      Comments: CommentsStore,
      Shares: ShareStore
    }
  }
&gt;
  &lt;div /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>Will pass the state from <code>BlogStore</code> (<code>BlogStore.getState()</code>) into the <code>&lt;div /&gt;</code> as <code>this.props.BlogPosts</code>. <code>CommentsStore</code> will be available in <code>this.props.Comments</code>, etc.</p>

<p>You can pass in a custom function as the value in order to control what each prop will represent. Say you have multiple getters on a store and only want to pass a subset of the state rather than the whole state. These functions must return a special object in order to let AltContainer know which store they’ll listen to.</p>

<pre><code class="language-js">&lt;AltContainer
  stores={
    {
      post: function (props) {
        return {
          store: BlogStore,
          value: BlogStore.getPostFor(props.blogId)
        };
      },
      comments: function (props) {
        return {
          store: CommentsStore,
          value: CommentsStore.getCommentsFor(props.blogId)
        };
      },
      shares: function (props) {
        return {
          store: ShareStore,
          value: ShareStore.getSharesFor(props.blogId)
        };
      }
    }
  }
&gt;
  &lt;BlogPost /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>If you pass an Array to <code>stores</code> the stores described will only be listened to.</p>

<pre><code class="language-js">&lt;AltContainer stores={[BlogStore]}&gt;
  &lt;BlogPost /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>The example above will only listen to BlogStore and re-render BlogPost when state changes in BlogStore. You can combine this with <code>inject</code> for full control of what gets added and listened to.</p>

<h2 id="inject"><code>inject</code></h2>

<p>This allows you to inject anything into your children. Functions defined inside inject are evaluated and their results passed down via props.</p>

<pre><code class="language-js">&lt;AltContainer
  stores={[BlogStore]}
  inject={ {
    className: 'blog-post',
    blogId: function (props) {
      return BlogStore.getState().id
    }
  } }&gt;
  &lt;BlogPost /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>The above example will pass the <code>className</code> of blog-post to BlogPost component. BlogPost wil also receive <code>blogId</code> as a prop which will be evaluated whenever BlogStore changes.</p>

<h2 id="store"><code>store</code></h2>

<p>If you only have a single store you can use <code>store</code> to bind it. The state will then be passed as props straight through.</p>

<pre><code class="language-js">var PostStore = alt.createStore({
  displayName: 'PostStore',
  state: {
    id: 1,
    title: 'Hello, World!'
  }
});

&lt;AltContainer store={PostStore}&gt;
  &lt;BlogPost /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p><code>BlogPost</code> in this case will receive all the state of <code>PostStore</code> as props. <code>this.props.id</code> and <code>this.props.title</code> will be passed through to <code>BlogPost</code>.</p>

<p>Just like <code>stores</code>, you can define your own custom function to use with <code>store</code>.</p>

<pre><code class="language-js">
function blogStoreFetcher(props) {
  return {
    store: BlogStore,
    value: BlogStore.getPostFor(props.blogId)
  };
}

&lt;AltContainer store={blogStoreFetcher}&gt;
  &lt;BlogPost /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>Children will get the properties you define.</p>

<pre><code class="language-js">&lt;AltContainer store={BlogStore}&gt;
  &lt;BlogPost className="my-awesome-post" /&gt;
&lt;/AltContainer&gt;
</code></pre>

<h2 id="actions"><code>actions</code></h2>

<p>You can directly inject any actions you wish to make available to your child components which will then be available via their props.</p>

<p>For example, say you have a pretty standard <code>BlogActions</code>.</p>

<pre><code class="language-js">var BlogActions = alt.generateActions('makePost');
</code></pre>

<p>You can inject these actions into BlogPost like so:</p>

<pre><code class="language-js">&lt;AltContainer
  store={BlogStore}
  actions={ { MyActions: BlogActions } }
&gt;
  &lt;BlogPost className="my-awesome-post" /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>The actions found in <code>BlogActions</code> will now be available in an object you defined <code>MyActions</code>. So you may call <code>this.props.MyActions.makePost()</code> and the <code>BlogActions.makePost</code> action will be fired.</p>

<p>You can inject these actions directly on the props themselves:</p>

<pre><code class="language-js">&lt;AltContainer
  store={BlogStore}
  actions={BlogActions}
&gt;
  &lt;BlogPost className="my-awesome-post" /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p><code>BlogPost</code> here will receive all of the state of <code>BlogStore</code> as props, and all of the actions of <code>BlogActions</code>. So you may call <code>this.props.makePost()</code> and the <code>BlogActions.makePost</code> action will be fired.</p>

<p>Similar to stores and store the actions prop also accepts a function where you can customize the behavior of the actions:</p>

<pre><code class="language-js">&lt;AltContainer
  store={BlogStore}
  actions={function (props) {
    return {
      makePost: function (postText) {
        // trim the post first
        postText.trim()

        // then call the action
        return BlogActions.makePost(postText)
      }
    }
  }}&gt;
  &lt;BlogPost className="my-awesome-post" /&gt;
&lt;/AltContainer&gt;
</code></pre>

<h2 id="render"><code>render</code></h2>

<p>But you can also specify a special <code>render</code> function which will render whatever your heart desires.</p>

<pre><code class="language-js">&lt;AltContainer
  store={BlogStore}
  render={function (props) {
    return &lt;BlogPost className="my-awesome-post" id={props.id} title="Overriding the title" /&gt;
  }}
/&gt;
</code></pre>

<h2 id="flux"><code>flux</code></h2>

<p><code>AltContainer</code> also works with Alt instances. If you’re passing the alt instance around as a <code>flux</code> prop, it’ll bind it to all its children.</p>

<pre><code class="language-js">const flux = new Flux();

&lt;AltContainer flux={flux}&gt;
  &lt;Header /&gt;
  &lt;Body /&gt;
  &lt;Footer /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>Header, Body, and Footer will have the <code>flux</code> context passed down.</p>

<h2 id="transform"><code>transform</code></h2>

<p>If you don’t like the way <code>AltContainer</code> passing the props, you can give it a <code>transform</code> function.</p>

<pre><code class="language-js">&lt;AltContainer
  stores={
    { BlogStore }
  }
  actions={
    { BlogActions }
  }
  transform={({ BlogStore, BlogActions }) =&gt; {
    var posts = BlogStore.posts.slice(0, 42);
    var makePost =
      text =&gt; BlogActions.makePost(`${text} So long, and thanks for all the fish.`);
    return { posts, makePost };
  }}&gt;
  &lt;Foobar /&gt;
&lt;/AltContainer&gt;
</code></pre>

<h2 id="shouldcomponentupdate"><code>shouldComponentUpdate</code></h2>

<p><code>shouldComponentUpdate</code> prop allows you to fine-tune your performance needs for AltContainer only rendering when absolutely necessary.</p>

<p>This is a function that gets called with the props that your children will receive. You return a boolean depending on if you wish to re-render or not.</p>

<pre><code class="language-js">&lt;AltContainer shouldComponentUpdate={(nextProps) =&gt; false}&gt;
  &lt;Header /&gt;
  &lt;Body /&gt;
  &lt;Footer /&gt;
&lt;/AltContainer&gt;
</code></pre>

<p>In this example, Header, Body, and Footer will not re-render because we’re returning false.</p>

<h2 id="component"><code>component</code></h2>

<p>With this prop you can define which component you want to render within your AltContainer. If you have a single component and you’re using required propTypes then this is a legitimate way of rendering the components without getting a warning about invalid propTypes from React due to cloneWithProps.</p>

<pre><code class="language-js">&lt;AltContainer component={Body} /&gt;
</code></pre>

<p>This example renders Body inside of the AltContainer.</p>

          </div>
        </div>
      </div>
    </div>

    <script type="application/javascript" src="http://alt.js.org/assets/search.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.js"></script>
<script type="text/javascript">
  // Alias for javascript so syntax highlighting works fine
  Prism.languages.js = Prism.languages.javascript;
</script>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.2.min.js" ></script>
<script type="text/javascript" src="/assets/bootstrap-navbar.min.js"></script>
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'goatslacker/alt'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>


  </body>

</html>
